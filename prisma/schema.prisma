// Prisma schema for Service Desk with multi-tenancy

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Model for grouping tenants (groups for admin panel)
model TenantGroup {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  tenants     Tenant[] // Tenants in this group
  
  @@map("tenant_groups")
}

// Model for organizations (tenants)
model Tenant {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  domain    String?  @unique
  
  // Custom domain support
  customDomain          String?  @unique
  customDomainVerified  Boolean  @default(false)
  dnsVerificationToken  String?  // Token for verification via TXT record
  sslEnabled            Boolean  @default(false)
  
  // Tenant grouping
  groupId   String?  // Optional group for combining tenants
  group     TenantGroup? @relation(fields: [groupId], references: [id], onDelete: SetNull)
  
  settings  Json?    @default("{\"ticketPrefix\": \"TICKET\", \"modules\": {\"queues\": true, \"sla\": false, \"knowledge\": false, \"automation\": false, \"cmdb\": false, \"reports\": true, \"webhooks\": false, \"ldap\": false}}") // Module settings and configuration
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  users     User[]
  tickets   Ticket[]
  categories Category[]
  invitations UserInvitation[]
  queues    Queue[]
  slaPolicies SlaPolicy[] // SLA policies
  customFields CustomField[] // Custom fields
  knowledgeArticles KnowledgeArticle[] // Knowledge base
  automationRules AutomationRule[] // Automation rules
  assets Asset[] // IT assets (CMDB)
  webhooks Webhook[] // Webhooks
  ldapConfigs LdapConfig[] // LDAP/SSO configurations
  subscription Subscription? // Subscription and billing
  telegramBots TelegramBot[] // Telegram bots
  supportTickets SupportTicket[] // Support tickets from organization admins
  
  @@index([groupId])
  @@map("tenants")
}

// User roles
enum UserRole {
  ADMIN       // Global administrator (sees all tenants)
  TENANT_ADMIN // Administrator of specific organization
  AGENT       // Support agent
  USER        // Regular user
}

// Agent statuses
enum AgentStatus {
  AVAILABLE   // Available
  BUSY        // Busy
  AWAY        // Away
  ON_LEAVE    // On leave
}

// Users
model User {
  id            String      @id @default(cuid())
  email         String      @unique
  name          String?
  password      String
  role          UserRole    @default(USER)
  avatar        String?
  isActive      Boolean     @default(true)
  agentStatus   AgentStatus @default(AVAILABLE) // Agent status (only for AGENT)
  tenantId      String?     // Optional: null for global administrators
  permissions   Json?       // Modular permissions for agents
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  tenant        Tenant?   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdTickets Ticket[] @relation("TicketCreator")
  assignedTickets Ticket[] @relation("TicketAssignee")
  comments      Comment[]
  categoryAssignments CategoryAgentAssignment[]
  notifications Notification[]
  readComments CommentRead[] // Tracking read comments
  sentInvitations UserInvitation[] // Invitations sent by user
  notificationSettings NotificationSettings? // User notification settings
  savedFilters SavedFilter[] // Saved ticket filters
  supportComments SupportComment[] @relation("SupportCommentAuthor") // Comments in support tickets
  
  @@index([tenantId])
  @@index([email])
  @@map("users")
}

// Ticket statuses
enum TicketStatus {
  OPEN        // Open
  IN_PROGRESS // In progress
  PENDING     // Pending
  RESOLVED    // Resolved
  CLOSED      // Closed
}

// Priorities
enum TicketPriority {
  LOW         // Low
  MEDIUM      // Medium
  HIGH        // High
  URGENT      // Urgent
}

// Queues for grouping tickets
model Queue {
  id          String   @id @default(cuid())
  name        String
  description String?
  color       String   @default("#8b5cf6")
  icon        String?  // Icon for queue
  isActive    Boolean  @default(true)
  priority    Int      @default(0) // Display priority
  tenantId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tickets   Ticket[]
  
  @@index([tenantId])
  @@index([isActive])
  @@map("queues")
}

// Ticket categories
model Category {
  id          String   @id @default(cuid())
  name        String
  description String?
  color       String   @default("#3b82f6")
  tenantId    String
  createdAt   DateTime @default(now())
  
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tickets   Ticket[]
  agentAssignments CategoryAgentAssignment[]
  
  @@index([tenantId])
  @@map("categories")
}

// Category assignments to agents
model CategoryAgentAssignment {
  id         String   @id @default(cuid())
  categoryId String
  agentId    String
  createdAt  DateTime @default(now())
  
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  agent      User     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  
  @@unique([categoryId, agentId])
  @@index([categoryId])
  @@index([agentId])
  @@map("category_agent_assignments")
}

// Tickets
model Ticket {
  id          String         @id @default(cuid())
  number      Int?           // Automatic ticket number (per-tenant), generated programmatically
  title       String
  description String         @db.Text
  status      TicketStatus   @default(OPEN)
  priority    TicketPriority @default(MEDIUM)
  tenantId    String
  queueId     String?        // Ticket queue
  categoryId  String?
  creatorId   String
  assigneeId  String?
  slaId       String?        // SLA policy
  slaDueDate  DateTime?      // SLA due date
  slaBreached Boolean        @default(false) // SLA breached
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  resolvedAt  DateTime?
  firstResponseAt DateTime?  // First response time
  lastViewedByCreatorAt DateTime? @default(now()) // For tracking unread comments
  
  tenant      Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  queue       Queue?         @relation(fields: [queueId], references: [id], onDelete: SetNull)
  category    Category?      @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  creator     User           @relation("TicketCreator", fields: [creatorId], references: [id])
  assignee    User?          @relation("TicketAssignee", fields: [assigneeId], references: [id])
  slaPolicy   SlaPolicy?     @relation(fields: [slaId], references: [id], onDelete: SetNull)
  comments    Comment[]
  attachments Attachment[]
  notifications Notification[]
  customFieldValues CustomFieldValue[] // Значения кастомных полей
  
  @@unique([tenantId, number]) // Number uniqueness within tenant
  @@index([tenantId])
  @@index([queueId])
  @@index([creatorId])
  @@index([assigneeId])
  @@index([status])
  @@index([priority])
  @@index([slaId])
  @@index([slaDueDate])
  @@index([slaBreached])
  @@map("tickets")
}

// Ticket comments
model Comment {
  id        String   @id @default(cuid())
  content   String   @db.Text
  ticketId  String
  authorId  String
  isInternal Boolean @default(false) // Internal comment (only for agents)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  author    User     @relation(fields: [authorId], references: [id])
  readBy    CommentRead[] // Who read the comment
  
  @@index([ticketId])
  @@index([authorId])
  @@map("comments")
}

// Attachments
model Attachment {
  id        String   @id @default(cuid())
  filename  String
  filepath  String
  mimetype  String
  size      Int
  ticketId  String
  createdAt DateTime @default(now())
  
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  @@index([ticketId])
  @@map("attachments")
}


// Notification types
enum NotificationType {
  TICKET_CREATED    // New ticket
  TICKET_ASSIGNED   // Ticket assigned
  TICKET_UPDATED    // Ticket updated
  COMMENT_ADDED     // Comment added
  TICKET_RESOLVED   // Ticket resolved
  TICKET_CLOSED     // Ticket closed
}

// Notifications
model Notification {
  id              String           @id @default(cuid())
  type            NotificationType
  title           String
  message         String
  isRead          Boolean          @default(false)
  userId          String
  ticketId        String?
  groupId         String?          // Notification group (for grouping)
  priority        String           @default("normal") // low, normal, high, urgent
  channels        String[]         @default(["IN_APP"]) // Delivery channels
  emailSent       Boolean          @default(false) // Email sent
  metadata        Json?            // Additional data (for custom notifications)
  createdAt       DateTime         @default(now())
  
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  ticket          Ticket?          @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  group           NotificationGroup? @relation(fields: [groupId], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([ticketId])
  @@index([groupId])
  @@index([isRead])
  @@index([priority])
  @@index([createdAt])
  @@map("notifications")
}

// Tracking read comments
model CommentRead {
  id        String   @id @default(cuid())
  userId    String
  commentId String
  readAt    DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  
  @@unique([userId, commentId])
  @@index([userId])
  @@index([commentId])
  @@map("comment_reads")
}

// User invitations
model UserInvitation {
  id        String   @id @default(cuid())
  email     String
  role      UserRole
  tenantId  String
  invitedBy String
  token     String   @unique
  expiresAt DateTime
  isUsed    Boolean  @default(false)
  createdAt DateTime @default(now())
  
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  inviter   User     @relation(fields: [invitedBy], references: [id])
  
  @@index([tenantId])
  @@index([email])
  @@index([token])
  @@map("user_invitations")
}

// SLA Policies (Service Level Agreement)
model SlaPolicy {
  id                    String   @id @default(cuid())
  name                  String
  description           String?
  tenantId              String
  isActive              Boolean  @default(true)
  
  // Time in minutes
  responseTime          Int?     // First response time (in minutes)
  resolutionTime        Int      // Resolution time (in minutes)
  
  // Application conditions
  priorities            String[] @default([]) // Priorities to which it applies
  categoryIds           String[] @default([]) // Categories to which it applies
  queueIds              String[] @default([]) // Queues to which it applies
  
  // Business hours (optional)
  businessHoursOnly     Boolean  @default(false)
  businessHoursStart    String?  // "09:00"
  businessHoursEnd      String?  // "18:00"
  businessDays          Int[]    @default([1, 2, 3, 4, 5]) // 1-7 (Monday-Sunday)
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  tenant                Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tickets               Ticket[]
  
  @@index([tenantId])
  @@index([isActive])
  @@map("sla_policies")
}

// Audit log (history of all actions)
model AuditLog {
  id            String   @id @default(cuid())
  tenantId      String
  userId        String?   // Can be null for system actions
  action        String    // Action type: CREATE, UPDATE, DELETE, LOGIN, etc
  resourceType  String    // Resource type: TICKET, USER, CATEGORY, etc
  resourceId    String?   // Resource ID
  metadata      Json?     // Additional data (what exactly changed)
  ipAddress     String?
  userAgent     String?
  createdAt     DateTime  @default(now())
  
  @@index([tenantId])
  @@index([userId])
  @@index([resourceType])
  @@index([resourceId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

// Custom field types
enum CustomFieldType {
  TEXT        // Text field
  NUMBER      // Number field
  DATE        // Date
  CHECKBOX    // Checkbox (Boolean)
  SELECT      // Select from list
  MULTI_SELECT // Multi-select
  URL         // URL
  EMAIL       // Email
}

// Custom field definitions (configured at tenant level)
model CustomField {
  id          String          @id @default(cuid())
  name        String          // Field name (internal)
  label       String          // Display label
  description String?         // Field description
  type        CustomFieldType // Field type
  options     Json?           // Options for SELECT/MULTI_SELECT: ["Option1", "Option2"]
  isRequired  Boolean         @default(false) // Whether field is required
  isActive    Boolean         @default(true)
  order       Int             @default(0) // Display order
  tenantId    String
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  
  tenant      Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  values      CustomFieldValue[]
  
  @@unique([tenantId, name]) // Unique name within tenant
  @@index([tenantId])
  @@index([isActive])
  @@map("custom_fields")
}

// Custom field values for tickets
model CustomFieldValue {
  id            String      @id @default(cuid())
  customFieldId String
  ticketId      String
  value         String      @db.Text // Stored as string, parsed by type
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  customField   CustomField @relation(fields: [customFieldId], references: [id], onDelete: Cascade)
  ticket        Ticket      @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  @@unique([customFieldId, ticketId]) // One value per field per ticket
  @@index([customFieldId])
  @@index([ticketId])
  @@map("custom_field_values")
}

// Notification delivery channels
enum NotificationChannel {
  IN_APP      // In app
  EMAIL       // Email
  PUSH        // Push notifications (for future)
}

// User notification settings
model NotificationSettings {
  id                        String   @id @default(cuid())
  userId                    String   @unique
  
  // Delivery channels
  enableInApp               Boolean  @default(true)
  enableEmail               Boolean  @default(true)
  enablePush                Boolean  @default(false)
  
  // Notification grouping
  groupSimilar              Boolean  @default(true)    // Group similar notifications
  groupingInterval          Int      @default(15)      // Grouping interval in minutes
  
  // Email notification frequency
  emailFrequency            String   @default("instant") // instant, hourly, daily, off
  emailDigestTime           String?  @default("09:00")  // Digest send time (HH:MM)
  
  // Notification types (enable/disable)
  notifyTicketCreated       Boolean  @default(true)
  notifyTicketAssigned      Boolean  @default(true)
  notifyTicketStatusChanged Boolean  @default(true)
  notifyTicketCommented     Boolean  @default(true)
  notifyTicketMentioned     Boolean  @default(true)
  notifyTicketEscalated     Boolean  @default(true)
  notifySlaBreach           Boolean  @default(true)
  
  // Priority notifications (always send)
  priorityOverride          Boolean  @default(true)    // Always send urgent tickets
  
  // Quiet hours
  quietHoursEnabled         Boolean  @default(false)
  quietHoursStart           String?  @default("22:00") // HH:MM
  quietHoursEnd             String?  @default("08:00") // HH:MM
  
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
  
  user                      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@map("notification_settings")
}

// Notification groups (for grouping similar ones)
model NotificationGroup {
  id              String         @id @default(cuid())
  userId          String
  type            String         // Type of notifications in group
  resourceType    String?        // TICKET, COMMENT, etc
  resourceId      String?        // Resource ID (e.g., ticketId)
  count           Int            @default(1)      // Number of notifications in group
  firstEventAt    DateTime       @default(now())  // First event time
  lastEventAt     DateTime       @default(now())  // Last event time
  isRead          Boolean        @default(false)
  isDismissed     Boolean        @default(false)
  
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  notifications   Notification[]
  
  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@index([resourceType, resourceId])
  @@index([lastEventAt])
  @@map("notification_groups")
}

// Saved ticket filters
model SavedFilter {
  id              String   @id @default(cuid())
  userId          String
  tenantId        String
  name            String          // Filter name
  description     String?         // Description
  icon            String?         // Icon (emoji or icon name)
  color           String?         // Label color
  isDefault       Boolean  @default(false) // Default filter
  isPublic        Boolean  @default(false) // Shared filter for entire team
  sortOrder       Int      @default(0)     // Display order
  
  // Filter conditions (JSON)
  filters         Json     // { status: ["OPEN"], priority: ["HIGH"], assigneeId: "xxx", ... }
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([tenantId])
  @@index([isPublic])
  @@map("saved_filters")
}

// ====================
// KNOWLEDGE BASE
// ====================

// Article statuses
enum ArticleStatus {
  DRAFT       // Draft
  PUBLISHED   // Published
  ARCHIVED    // Archived
}

// Knowledge base articles
model KnowledgeArticle {
  id              String        @id @default(cuid())
  title           String
  slug            String        // URL-friendly name
  content         String        @db.Text
  excerpt         String?       // Short description
  status          ArticleStatus @default(DRAFT)
  tenantId        String
  authorId        String
  categoryId      String?       // Article category (can use Category)
  views           Int           @default(0)
  isPublic        Boolean       @default(false) // Available to users?
  tags            String[]      @default([])
  attachments     String[]      @default([]) // File URLs
  version         Int           @default(1)
  publishedAt     DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  tenant          Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  @@unique([tenantId, slug])
  @@index([tenantId])
  @@index([status])
  @@index([authorId])
  @@index([publishedAt])
  @@map("knowledge_articles")
}

// ====================
// AUTOMATION
// ====================

// Trigger types
enum TriggerType {
  TICKET_CREATED      // On ticket creation
  TICKET_UPDATED      // On ticket update
  TICKET_ASSIGNED     // On ticket assignment
  STATUS_CHANGED      // On status change
  PRIORITY_CHANGED    // On priority change
  COMMENT_ADDED       // On comment added
  SLA_BREACH          // On SLA breach
  TIME_BASED          // Time-based (cron)
}

// Action types
enum ActionType {
  ASSIGN_TO_AGENT     // Assign to agent
  CHANGE_STATUS       // Change status
  CHANGE_PRIORITY     // Change priority
  ADD_COMMENT         // Add comment
  SEND_EMAIL          // Send email
  SEND_NOTIFICATION   // Send notification
  ADD_TAG             // Add tag
  CALL_WEBHOOK        // Call webhook
}

// Automation rules
model AutomationRule {
  id              String       @id @default(cuid())
  name            String
  description     String?
  tenantId        String
  isActive        Boolean      @default(true)
  triggerType     TriggerType
  conditions      Json         // Conditions: { field: "priority", operator: "equals", value: "HIGH" }
  actions         Json         // Actions: [{ type: "ASSIGN_TO_AGENT", agentId: "xxx" }]
  priority        Int          @default(0) // Execution order (lower = earlier)
  executionCount  Int          @default(0) // Number of executions
  lastExecutedAt  DateTime?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  
  tenant          Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  @@index([tenantId])
  @@index([isActive])
  @@index([triggerType])
  @@map("automation_rules")
}

// ====================
// CMDB / ASSETS (IT Infrastructure)
// ====================

// Asset types
enum AssetType {
  COMPUTER        // Computer
  LAPTOP          // Laptop
  SERVER          // Server
  NETWORK         // Network equipment
  PRINTER         // Printer
  PHONE           // Phone
  MOBILE          // Mobile device
  SOFTWARE        // Software
  LICENSE         // License
  OTHER           // Other
}

// Asset statuses
enum AssetStatus {
  IN_USE          // In use
  AVAILABLE       // Available
  MAINTENANCE     // Under maintenance
  RETIRED         // Retired
  LOST            // Lost
}

// IT assets (CMDB)
model Asset {
  id              String       @id @default(cuid())
  name            String
  type            AssetType
  status          AssetStatus  @default(AVAILABLE)
  tenantId        String
  assignedToId    String?      // Assigned to (User)
  locationId      String?      // Location/office
  manufacturer    String?
  model           String?
  serialNumber    String?
  inventoryNumber String?
  purchaseDate    DateTime?
  warrantyExpiry  DateTime?
  notes           String?      @db.Text
  customData      Json?        // Additional fields (IP, MAC, etc)
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  
  tenant          Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  @@index([tenantId])
  @@index([type])
  @@index([status])
  @@index([assignedToId])
  @@index([serialNumber])
  @@map("assets")
}

// ====================
// WEBHOOKS
// ====================

// События webhook
enum WebhookEvent {
  TICKET_CREATED
  TICKET_UPDATED
  TICKET_RESOLVED
  TICKET_CLOSED
  COMMENT_ADDED
  USER_CREATED
  CATEGORY_CREATED
  ALL                 // Все события
}

// Webhooks
model Webhook {
  id              String         @id @default(cuid())
  name            String
  url             String
  secret          String?        // Secret для подписи
  events          WebhookEvent[] @default([])
  isActive        Boolean        @default(true)
  tenantId        String
  headers         Json?          // Дополнительные заголовки
  successCount    Int            @default(0)
  failureCount    Int            @default(0)
  lastTriggeredAt DateTime?
  lastError       String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  tenant          Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  deliveries      WebhookDelivery[]
  
  @@index([tenantId])
  @@index([isActive])
  @@map("webhooks")
}

// Webhook delivery history
model WebhookDelivery {
  id              String   @id @default(cuid())
  webhookId       String
  event           String
  payload         Json
  statusCode      Int?
  response        String?  @db.Text
  error           String?  @db.Text
  duration        Int?     // Execution time in ms
  retriesLeft     Int      @default(3)
  createdAt       DateTime @default(now())
  
  webhook         Webhook  @relation(fields: [webhookId], references: [id], onDelete: Cascade)
  
  @@index([webhookId])
  @@index([createdAt])
  @@map("webhook_deliveries")
}

// ====================
// LDAP / SSO
// ====================

// Authentication types
enum AuthProviderType {
  LDAP
  ACTIVE_DIRECTORY
  OAUTH2
  SAML
}

// LDAP/SSO configurations
model LdapConfig {
  id              String           @id @default(cuid())
  name            String
  type            AuthProviderType
  tenantId        String
  isActive        Boolean          @default(false)
  
  // LDAP/AD settings
  host            String?
  port            Int?             @default(389)
  useSSL          Boolean?         @default(false) // Use LDAPS (SSL/TLS)
  baseDn          String?
  bindDn          String?
  bindPassword    String?
  userSearchBase  String?
  userSearchFilter String?
  groupSearchBase String?
  groupSearchFilter String?
  
  // OAuth2/SAML settings
  clientId        String?
  clientSecret    String?
  authorizationUrl String?
  tokenUrl        String?
  userInfoUrl     String?
  callbackUrl     String?
  
  // Attribute mapping
  attributeMapping Json?           // { email: "mail", name: "cn", ... }
  groupMapping     Json?           // { "CN=Admins": "TENANT_ADMIN" }
  
  // Synchronization settings
  syncEnabled      Boolean         @default(false)
  syncInterval     Int?            @default(3600) // In seconds
  lastSyncAt       DateTime?
  
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  
  tenant           Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  @@index([tenantId])
  @@index([isActive])
  @@map("ldap_configs")
}

// ==============================================
// Billing & Subscriptions
// ==============================================

// Subscription plans
enum PlanType {
  FREE        // Free: 10 users, 2 agents, 1GB storage
  PRO         // PRO: 50 users, 15 agents, 20GB storage, SLA, KB, Assets
  ENTERPRISE  // Enterprise: Unlimited, all modules, SSO, custom support
}

// Subscription statuses
enum SubscriptionStatus {
  ACTIVE        // Active
  TRIALING      // Trialing
  PAST_DUE      // Past due
  CANCELED      // Canceled
  INCOMPLETE    // Incomplete
  UNPAID        // Unpaid
}

// Subscription model
model Subscription {
  id                      String              @id @default(cuid())
  tenantId                String              @unique
  plan                    PlanType            @default(FREE)
  status                  SubscriptionStatus  @default(ACTIVE)
  
  // Stripe IDs
  stripeCustomerId        String?             @unique
  stripeSubscriptionId    String?             @unique
  stripePriceId           String?
  
  // Subscription period
  currentPeriodStart      DateTime?
  currentPeriodEnd        DateTime?
  cancelAtPeriodEnd       Boolean             @default(false)
  canceledAt              DateTime?
  trialStart              DateTime?
  trialEnd                DateTime?
  
  // Plan limits
  maxUsers                Int                 @default(10)      // Maximum users
  maxAgents               Int                 @default(2)       // Maximum agents
  maxStorageGB            Int                 @default(1)       // Maximum storage (GB)
  maxTicketsPerMonth      Int?                // Ticket limit per month (null = unlimited)
  
  // Enabled features
  ssoEnabled              Boolean             @default(false)   // SSO available
  customDomainEnabled     Boolean             @default(false)   // Custom domain
  apiAccessEnabled        Boolean             @default(false)   // API access
  prioritySupportEnabled  Boolean             @default(false)   // Priority support
  customBrandingEnabled   Boolean             @default(false)   // Custom branding
  
  // Metadata
  metadata                Json?               // Additional data
  
  createdAt               DateTime            @default(now())
  updatedAt               DateTime            @updatedAt
  
  tenant                  Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invoices                Invoice[]
  usageRecords            UsageRecord[]
  
  @@index([status])
  @@index([plan])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@map("subscriptions")
}

// Invoices
model Invoice {
  id                    String   @id @default(cuid())
  subscriptionId        String
  
  stripeInvoiceId       String?  @unique
  amountDue             Int      // In cents
  amountPaid            Int      @default(0)
  currency              String   @default("usd")
  status                String   // draft, open, paid, void, uncollectible
  
  // Invoice period
  periodStart           DateTime
  periodEnd             DateTime
  
  // Dates
  dueDate               DateTime?
  paidAt                DateTime?
  
  // Links
  hostedInvoiceUrl      String?  // Stripe hosted page
  invoicePdf            String?  // PDF URL
  
  metadata              Json?
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  subscription          Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  
  @@index([subscriptionId])
  @@index([status])
  @@index([stripeInvoiceId])
  @@map("invoices")
}

// Usage records (for metrics)
model UsageRecord {
  id                    String   @id @default(cuid())
  subscriptionId        String
  
  // Metric
  metricType            String   // users, agents, storage, tickets, api_calls
  metricValue           Int      // Current value
  maxValue              Int?     // Maximum value (limit)
  
  // Period
  periodStart           DateTime
  periodEnd             DateTime
  
  metadata              Json?
  
  createdAt             DateTime @default(now())
  
  subscription          Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  
  @@index([subscriptionId])
  @@index([metricType])
  @@index([periodStart])
  @@map("usage_records")
}

// ============================================
// TELEGRAM BOT INTEGRATION (per-tenant)
// ============================================

model TelegramBot {
  id              String   @id @default(cuid())
  tenantId        String
  
  // Bot credentials
  botToken        String   // Telegram Bot API Token
  botUsername     String   // Bot @username
  
  // Settings
  isActive        Boolean  @default(true)
  
  // Notification groups
  groupChatId     String?  // Group ID for agent notifications
  
  // Notification settings
  notifyOnNewTicket         Boolean @default(true)
  notifyOnTicketUpdate      Boolean @default(true)
  notifyOnNewComment        Boolean @default(true)
  
  // Permissions
  allowTicketCreation       Boolean @default(true)
  allowTicketStatusChange   Boolean @default(false)
  
  // Webhook
  webhookUrl      String?
  lastWebhookUpdateAt DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  users           TelegramUser[] // Links between ServiceDesk users and Telegram accounts
  messages        TelegramMessage[] // Message history
  
  @@unique([tenantId]) // One bot per tenant
  @@index([botToken])
  @@map("telegram_bots")
}

// Link between ServiceDesk users and Telegram accounts
model TelegramUser {
  id              String   @id @default(cuid())
  botId           String
  userId          String   // ServiceDesk user ID
  
  // Telegram data
  telegramId      String   // Telegram user ID (chat ID)
  telegramUsername String?  // @username (if exists)
  firstName       String?
  lastName        String?
  
  // Status
  isVerified      Boolean  @default(false)
  verificationCode String?
  verifiedAt      DateTime?
  
  // Settings
  notificationsEnabled Boolean @default(true)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  bot             TelegramBot @relation(fields: [botId], references: [id], onDelete: Cascade)
  
  @@unique([botId, telegramId]) // One Telegram account per bot
  @@unique([botId, userId]) // One user can be linked to only one Telegram account per bot
  @@index([telegramId])
  @@index([userId])
  @@map("telegram_users")
}

// Telegram message history
model TelegramMessage {
  id              String   @id @default(cuid())
  botId           String
  
  // Telegram data
  telegramMessageId String // Telegram message ID
  telegramChatId    String // Chat ID
  
  // Link to ticket
  ticketId        String?
  
  // Content
  messageType     String   // text, photo, document, command
  text            String?
  
  // Direction
  direction       String   // incoming (from user) | outgoing (from bot)
  
  // Metadata
  metadata        Json?
  
  createdAt       DateTime @default(now())
  
  bot             TelegramBot @relation(fields: [botId], references: [id], onDelete: Cascade)
  
  @@index([botId])
  @@index([ticketId])
  @@index([telegramChatId])
  @@index([createdAt])
  @@map("telegram_messages")
}

// Support tickets for communication between Tenant Admin and Super Admin
model SupportTicket {
  id          String   @id @default(cuid())
  number      Int      @default(autoincrement()) // Unique ticket number
  
  title       String
  description String   @db.Text
  status      TicketStatus @default(OPEN)
  priority    TicketPriority @default(MEDIUM)
  
  // Link to organization (who the ticket is from)
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  // Creator (TENANT_ADMIN)
  creatorId   String
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  resolvedAt  DateTime?
  closedAt    DateTime?
  
  // Tracking read status (when tenant admin last viewed the ticket)
  lastViewedByCreatorAt DateTime? @default(now())
  
  // Tracking read status by super-admin (when super-admin last viewed the ticket)
  lastViewedByAdminAt DateTime? @default(now())
  
  // Comments
  comments    SupportComment[]
  
  // Attachments
  attachments SupportAttachment[]
  
  @@index([tenantId])
  @@index([creatorId])
  @@index([status])
  @@index([createdAt])
  @@map("support_tickets")
}

// Support ticket comments
model SupportComment {
  id        String   @id @default(cuid())
  content   String   @db.Text
  ticketId  String
  authorId  String   // User ID (can be TENANT_ADMIN or SUPER_ADMIN)
  
  isInternal Boolean @default(false) // Internal comment (only for super-admin)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  ticket    SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  author    User          @relation("SupportCommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  
  @@index([ticketId])
  @@index([authorId])
  @@index([createdAt])
  @@map("support_comments")
}

// Support ticket attachments
model SupportAttachment {
  id        String   @id @default(cuid())
  filename  String
  filepath  String
  mimetype  String
  size      Int
  ticketId  String
  createdAt DateTime @default(now())
  
  ticket    SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  @@index([ticketId])
  @@map("support_attachments")
}

